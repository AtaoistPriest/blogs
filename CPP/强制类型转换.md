| **转换方法**       | **转换时机** | **主要用途**                                                | **安全性**                   | **性能开销** |
| ------------------ | :----------: | ----------------------------------------------------------- | ---------------------------- | ------------ |
| `static_cast`      |    编译时    | 相关类型间转换（数值、`void*`、继承上行、**不安全的**下行） | 中等（程序员需保证下行安全） | 无           |
| `dynamic_cast`     |    运行时    | 多态继承中的**安全**下行和交叉转换                          | **高**（有检查机制）         | **有**       |
| `const_cast`       |    编译时    | **仅**添加或去除 `const`/`volatile`属性                     | **低**（滥用会导致UB）       | 无           |
| `reinterpret_cast` |    编译时    | 低层次、不相关的类型重新解释（如指针转整数）                | **极低**（极易导致UB）       | 无           |

**使用指南**

* 数值转换、明确的向上转换 --> `static_cast`
* **需要安全的向下转换（多态类）** -> `dynamic_cast`
* **需要调用一个非** `const` **API但又不修改数据** -> `const_cast`（并做好注释和祈祷）
* **与底层系统或硬件交互，需要直接操作比特** -> `reinterpret_cast`（并做好承担一切后果的准备）
* **绝对不要使用 C 风格转换** `(type)value`，用上面四种明确的转换来替代它。这让你的代码意图更清晰，也更安全

---



# 1、static_cast

这是最常用、最基础的转换，用于在**编译期**已知的、有某种关联的类型之间的转换。

**适用场景**

- **数值类型转换**：int → double,  float → int 等
- **类层次中的向上转换**（派生类→基类）：将派生类指针或引用转换为基类指针或引用。这是**安全**的，且编译器隐式进行的转换也属于此类。
- **可以**用于向下转换（Downcasting），但**不安全**（编译器不会检查转换的正确性），除非程序员非常确定目标类型是正确的。安全的向下转换应该使用 `**dynamic_cast**`。
- **void 指针与其他指针类型的互转，有类型检查；**

```cpp
// 基本类型转换
double d = 3.14;
int i = static_cast<int>(d); // 3
float f = static_cast<float>(i);

// 指针类型转换
class Base {};
class Derived : public Base {};
Derived d;
Base* b_ptr = static_cast<Base*>(&d); // 安全的上行转换

void* pv = malloc(sizeof(int));
int* pi = static_cast<int*>(pv);
*pi = 100;
```

# 2、dynamic_cast

​	专门用于处理**继承层次结构**中（通常涉及多态）的安全向下转换和交叉转换。它依赖于**运行时类型信息（RTTI）**，因此有一定的性能开销。



**适用场景**：

- **类层次中的向下转换**（基类→派生类）：将基类指针或引用转换为派生类指针或引用。这是其最主要、最核心的用途。

- **交叉转换**：在多重继承中，将一个指向派生类的基类子对象转换为另一个不相关的基类子对象。

  

**工作原理：** 

​	它在运行时检查指针/引用所指向的对象的实际类型。如果转换请求是有效的（即目标类型是对象实际类型的基类或派生类），则转换成功；否则：

- 对于指针类型，返回 `nullptr`。
- 对于引用类型，抛出 `std::bad_cast` 异常。



**重要限制**：

- 只能用于**包含虚函数**的类（多态类型），因为 RTTI 需要虚函数表。
- 有运行时开销；
- 不能用于内置基本数据类型之间的转换（如 `int`  转 `double`）

```cpp
class Shape {
public:
    virtual void draw() = 0;
    virtual ~Shape() {}
};

class Circle : public Shape {
public:
    void draw() override { std::cout << "Drawing circle" << std::endl; }
    void setRadius(double r) { radius = r; }
private:
    double radius;
};

class Square : public Shape {
public:
    void draw() override { std::cout << "Drawing square" << std::endl; }
    void setSide(double s) { side = s; }
private:
    double side;
};

void example_dynamic_cast() {
    Shape* shape = new Circle();
    
    // 安全的向下转换
    Circle* circle = dynamic_cast<Circle*>(shape);
    if (circle) {
        circle->setRadius(5.0);
        std::cout << "Successfully cast to Circle" << std::endl;
    }
    
    // 尝试转换为不匹配的类型
    Square* square = dynamic_cast<Square*>(shape);
    if (!square) {
        std::cout << "Failed to cast to Square (correct behavior)" << std::endl;
    }
    
    // 引用转换（失败会抛出std::bad_cast异常）
    try {
        Circle& circleRef = dynamic_cast<Circle&>(*shape);
        circleRef.setRadius(10.0);
    } catch (const std::bad_cast& e) {
        std::cout << "Bad cast: " << e.what() << std::endl;
    }
    
    delete shape;
}
```

# 3、const_cast

​	**适用场景**：只用于修改类型的 `**const**` 或 `**volatile**` 属性。这是**唯一**能完成此操作的 C++ 转换。不同用于不同类型变量之间的转换。

​	**具体用途**：

​	**（1）去除** `const` **属性**：这是最常见的用法，但请**极其谨慎地使用**。通常用于调用一些历史遗留的、参数不是 `**const**` 但你知道不会修改实参的函数。

​	总的来说就是进行接口的兼容性处理，如下面示例所示，旧接口的形参为非常量，但实参为常量。此时可以将实参进行 `const_cast` 处理，去除 `const` 属性。

​	**警告**：注意，虽然实参去除了 const 属性，但是并不代表其变为常量了，此时对该变量的任何写操作都是未定义行为。所以我们在使用该操作时，需要确保旧接口内不会修改该变量。

```cpp
void oldLibFunction(char* str); // 一个不会修改 str 的旧函数，但其参数没声明为 const

const char* my_str = "Hello";
// oldLibFunction(my_str); // 错误：无法将 ‘const char*’ 转换为 ‘char*’
oldLibFunction(const_cast<char*>(my_str)); // 可行，但有风险
```

​	**（2）添加** `const` **属性**：虽然不常用，但语法上允许。通常隐式转换就足够了。

```cpp
int x = 10;
const int* cx_ptr = const_cast<const int*>(&x);
```

# 4、reinterpret_cast

​	**适用场景**：提供低层次的、基于比特模式的“重新解释”。它将一个指针或引用的比特模式，不经过任何中间处理，直接解释为另一种类型的比特模式。这是**最危险**的转换，完全绕过了编译器的类型检查。

​	**具体用途：**

​	**（1） 在任意指针类型之间进行转换**（如 `MyClass*` 转 `int*`）。

​	**（2） 在指针和足够大的整数类型之间进行转换**（如 `void*` 转 `uintptr_t`）。

```cpp
int i = 42;
void* voidPtr = reinterpret_cast<void*>(&i);
int* intPtr = reinterpret_cast<int*>(voidPtr);

// 函数指针转换
typedef void (*FuncPtr)();
FuncPtr func = reinterpret_cast<FuncPtr>(0x12345678);
```

**警告**

- 它产生的代码是**高度平台依赖**的，不具备可移植性。
- 它的使用几乎总是意味着代码设计有问题，或者是在与底层硬件、操作系统接口打交道（例如驱动程序、序列化）。
- **滥用** `reinterpret_cast` **极易导致未定义行为**。除非你非常清楚自己在做什么，并且没有其他替代方案，否则应避免使用它。